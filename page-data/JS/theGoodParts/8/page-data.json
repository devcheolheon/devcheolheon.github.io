{"componentChunkName":"component---src-templates-blog-post-js","path":"/JS/theGoodParts/8/","result":{"data":{"site":{"siteMetadata":{"title":"DEV LOGS"}},"markdownRemark":{"id":"f7a2a1a1-4d92-5d3e-9da8-d87134a8bb97","excerpt":"정규 표현식 자바스크립트의 정규표현식은 Perl…","html":"<h3>정규 표현식</h3>\n<p>자바스크립트의 정규표현식은 Perl에서 가져온 것입니다. </p>\n<p>자바스크립트에서 정규 표현식은 보통 같은 문자열에 대해 반복해서\n연산을 수행할 때 주목할 만한 성능상의 이점이 있습니다. </p>\n<p>정규표현식은 정규 언어 대한 수학적 연구에서 비롯된 것입니다.\n정규 표현식은 엄격하게 정규적이지는 않지만 매우 유용합니다.\n정규 표현식은 매우 간결해지는 경향이 있습니다. </p>\n<h3>01 예제</h3>\n<h4>URL에 일치하는 정규 표현식</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> parse_url <span class=\"token operator\">=</span> <span class=\"token regex\">/^(?:([A-Za-z]+):)?(\\/{0,3})([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> url <span class=\"token operator\">=</span> <span class=\"token string\">\"http://www.ora.com:80/goodparts?q#fragment\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> parse_url<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">var</span> names <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'url'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'scheme'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'slash'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'host'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'port'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'path'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'query'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'hash'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">var</span> blanks <span class=\"token operator\">=</span> <span class=\"token string\">'        '</span> <span class=\"token punctuation\">;</span> \n\n<span class=\"token keyword\">var</span> i<span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> names<span class=\"token punctuation\">.</span>length <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>names<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token string\">':'</span> <span class=\"token operator\">+</span> blanks<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span>names<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>각 부분을 살펴보면 </p>\n<blockquote>\n<p>^ </p>\n</blockquote>\n<p>문자열의 시작을 나타냅니다. </p>\n<blockquote>\n<p>(?:([A-Za-z]+):)? </p>\n</blockquote>\n<p>프로토콜 이름에 일치하는 부분입니다.\n(?: …) 는 캡쳐하지 않는 그룹을 나타냅니다. </p>\n<p>각각의 캡쳐 그룹은 번호 주어지고, 결과 배열에 해당 인덱스에\n캡쳐 그룹에 일치하는 텍스트의 복사본이 주어집니다. </p>\n<blockquote>\n<p>/{0,3} </p>\n</blockquote>\n<p>백 슬래시가 / 정규 표현식에 슬래시로 잘못 해석되지 않게  \\를 통해 이스케이프 됩니다. </p>\n<blockquote>\n<p>([0-9.-A-Za-z])</p>\n</blockquote>\n<p>-는 범위를 나타내는 -와 혼동되지 않기 위히 \\를 통해 이스케이프 됩니다. </p>\n<blockquote>\n<p>(?::(\\d+))? </p>\n</blockquote>\n<p>옵션으로 올 수 있는 포트 번호입니다. : 다음에 하나 이상의 연속 숫자입니다. </p>\n<blockquote>\n<p>(?:/(<sup id=\"fnref-?#\"><a href=\"#fn-?#\" class=\"footnote-ref\">?#</a></sup>*))? </p>\n</blockquote>\n<p>*는 0번 이상 일치한다는 것을 의미합니다.\n^를 자주 사용할 경우, 여전히 원치 않는 문자가 끼어들 위험성이 남아있습니다. </p>\n<blockquote>\n<p>(?:?(<sup id=\"fnref-#\"><a href=\"#fn-#\" class=\"footnote-ref\">#</a></sup>*))?</p>\n</blockquote>\n<p>?로 시작하는 옵션 그룹입니다. #이 아닌 문자가 0번 이상 나오는 캡쳐 그룹이 포함됩니다. </p>\n<blockquote>\n<p>(?:#(.*))?</p>\n</blockquote>\n<h1>으로 시작하는 마지막 옵션 그룹입니다.</h1>\n<blockquote>\n<p>$</p>\n</blockquote>\n<p>문자열의 끝을 의미합니다.\n정규 표현식은 길이가 짧고 간단할 때 최상이라고 할 수 있습니다.\n단순함이 최상의 전략입니다. </p>\n<h4>숫자에 일치하는 정규표현식</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">  <span class=\"token keyword\">var</span> parse_number <span class=\"token operator\">=</span> <span class=\"token regex\">/^-?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d+)?$/i</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> <span class=\"token function-variable function\">test</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">num</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> parse_number<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  <span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>/^  $/i </p>\n</blockquote>\n<p>텍스트 내의 모든 문자가 정규 표현식과 대응되어야 함을 의미합니다.\ni 플래그는 문자를 검사할때 대소문자를 구분하지 않게 합니다. </p>\n<blockquote>\n<p>-? </p>\n</blockquote>\n<p>기호 - 뒤에 붙는 ?는 음수 기호가 옵션이라는 뜻</p>\n<blockquote>\n<p>\\d+ </p>\n</blockquote>\n<p>[0-9]+ 와 같은 의미입니다. </p>\n<blockquote>\n<p>(?:.\\d*)? </p>\n</blockquote>\n<p>(?: … )? 는 옵션인 비캡쳐 그룹을 나타냅니다.\n캠쳐 그룹은 성능상의 약점이 있기 때문에 보통의 경우 약간 복잡함이 더해지더라도\n캡처그룹보다는 비캡쳐 그룹을 사용하는 것이 좋습니다. </p>\n<blockquote>\n<p>(?:e[+-]?\\d+)? </p>\n</blockquote>\n<p>도 하나의 옵션인 비 캠쳐 그룹입니다. </p>\n<h3>정규 표현식 객체 생성</h3>\n<blockquote>\n<p>/” … “/g </p>\n</blockquote>\n<p>정규 표현식 리터럴을 활용하는 방법 </p>\n<table>\n<thead>\n<tr>\n<th>플래그</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>g</td>\n<td>Global(여러번 일치함, 정확한 의미는 메소드에 따라 다름</td>\n</tr>\n<tr>\n<td>i</td>\n<td>대소문자를 구분하지 않음</td>\n</tr>\n<tr>\n<td>m</td>\n<td>^ 과 $가 라인 끝 문자에 일치할 수 있음</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>new Regexp(” … ”, ‘g’); </p>\n</blockquote>\n<p>정규 표현식 생성자를 활용하는 방법</p>\n<p>lastIndex속성을 가지고 있음, 다음 exec 실행을 위한 시작점을 나타냄\n(초기값은 0)</p>\n<h3>구성요소</h3>\n<h4>선택</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token string\">\"into\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/in|int/</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>into에서 in으로 먼저 발견, in이 일치하는 것이 된다.</p>\n<h4>시퀀스</h4>\n<blockquote>\n<p>정규 표현식 요소  + 정규 표현식 수량자 </p>\n</blockquote>\n<p>정규표현식 요소 가 몇번 나오는지 나타내는 수량자를 선택적으로\n붙일 수 있다. </p>\n<h4>정규표현식 요소</h4>\n<p>정규표현식 요소는 문자 괄호로 묶인 그룹, 문자 클래스, 이스케이프 시퀀스 등이 될 수 있다. </p>\n<h4>이스케이프</h4>\n<p>\\d : 아라비아 숫자에 일치합니다.\n\\D : <sup id=\"fnref-0-9\"><a href=\"#fn-0-9\" class=\"footnote-ref\">0-9</a></sup> </p>\n<p>\\s : 유니코드 공백 문자의 집합\n\\S : \\s의 반대 </p>\n<p>\\w : [0-9A-Z_a-z]와 같습니다.\n\\W : \\w의 반대 .. 실제 언어를 다루는데 그다지 쓸모 있지 않습니다. </p>\n<p>\\b : 단어 경계를 나타내어 문자 기반으로 일치시키기 쉽게 하기 위해서 고안된 것 </p>\n<p>\\1 : 첫 번째 그룹에 캡처된 텍스트에 대한 참조 </p>\n<h4>그룹</h4>\n<h5>캡쳐</h5>\n<p>괄호로 묶인 정규 표현식 선택</p>\n<h5>비캡쳐</h5>\n<p>(?: 로 시작, 단순히 일치하는지 확인할 뿐이지 일치하는 텍스트를 캡처하지는 않습니다. </p>\n<h5>긍정형 룩어헤드</h5>\n<p>(?= 비 캡쳐 그룹과 유사한데 다만 일치되는 부분을 찾은 후에 그룹이 시작하는 지점으로 다시 돌립니다. </p>\n<h5>부정형 룩어헤드</h5>\n<p>(?! 찾지 못했을때가 일치하는 경우가 됨</p>\n<h4>문자 클래스</h4>\n<p>하이픈 - 를 통해 범위를 나타낼 수 있다. </p>\n<p>클래스 내에  이스케이프 하는 방법은 정규 표현식 요소와 다르다. </p>","frontmatter":{"title":"7 - 정규 표현식","date":null,"description":null}}},"pageContext":{"slug":"/JS/theGoodParts/8/","previous":{"fields":{"slug":"/FP/FPinJS/8/"},"frontmatter":{"title":"CHAPTER 8 - 비동기 이벤트와 데이터를 관리"}},"next":{"fields":{"slug":"/FP/FPinJS/9/"},"frontmatter":{"title":"APPENDIX"}}}}}